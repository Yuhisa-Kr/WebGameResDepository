<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multiple Rush - Playground</title>

  <style>
    /* ===== Font ===== */
    @font-face{
      font-family: "NanumHumanHeavy";
      src: url("https://raw.githubusercontent.com/Yuhisa-Kr/WebCardGame/main/NanumHumanHeavy.ttf") format("truetype");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }

    :root{
      --bg:#1a1322;
      --accent:#c3a9e0;
      --gold:#f8cf57;
      --glow: rgba(239,161,77,0.70);

      --card-w:141px;
      --card-h:250px;
      --gap:18px;
      --bottom-safe: 92px;

      /* 결과 소거 점 크기 */
      --dotR: 20px;
      --dotR-gap: 7px;

      /* dot “중앙 기준” 간격 */
      --dotW: 50px;
      --dotH: 50px;
      --dotCenterX: 30px; /* 중앙-중앙 가로 간격 */
      --dotCenterY: 50px; /* 중앙-중앙 세로 간격 */
      --dotDoubleGap: 45px; /* 9 + 9 사이 간격 */

      /* ✅ Background */
      --bgTop:#1a1322;
      --bgBot:#2b0654;
      --bgImg:url("https://raw.githubusercontent.com/Yuhisa-Kr/WebCardGame/refs/heads/main/MR_Background.png");
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      height:100vh;
      overflow:hidden;
      color: rgba(255,255,255,0.92);

      font-family: "NanumHumanHeavy", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;

      /* ✅ 1) 전체 화면 그라데이션 바탕 */
      background: linear-gradient(180deg, var(--bgTop) 0%, var(--bgBot) 100%);
      position: relative;
    }

    /* ✅ 2) 빈 공간 채우는 “블러 커버” */
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -2;
      background-image: var(--bgImg);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;

      filter: blur(22px) brightness(0.82) saturate(1.05);
      transform: scale(1.08);
    }

    /* ✅ 3) 원본 비율 그대로(안 잘림) */
    body::after{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      background-image: var(--bgImg);
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 1;
    }

    .wrap::before {
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background: radial-gradient(
        60% 40% at 50% 35%,
        rgba(0,0,0,0),
        rgba(0,0,0,0.35)
      );
    }

    .wrap{
      width: min(1600px, 100%);
      margin: 0 auto;
      padding: 22px 22px calc(var(--bottom-safe) + 12px);
      height: 100vh;
      display:flex;
      flex-direction:column;
      gap: 14px;
      align-items:center;
    }

    /* ===== Start Cover ===== */
    .startCover{
      position:fixed;
      inset:0;
      z-index: 1000;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: opacity 220ms ease;
    }
    .startCover.hide{
      opacity:0;
      pointer-events:none;
    }
    .startPanel{
      width: min(720px, 92vw);
      padding: 24px 22px 20px;
      border-radius: 22px;
      background: rgba(26,19,34,0.78);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 18px 60px rgba(0,0,0,0.65);
      text-align:center;
    }
    .startMsg{
      margin: 6px 0 14px;
      font-size: 34px;
      font-weight: 1100;
      letter-spacing: 0.4px;
      text-shadow: 0 0 18px rgba(0,0,0,0.60);
    }

    button{
      cursor:pointer;
      border: 0;
      border-radius: 16px;
      padding: 12px 18px;
      font-weight: 1100;
      letter-spacing: 0.3px;
      background: var(--accent);
      color: #110b18;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      transition: transform .08s ease, filter .08s ease, opacity .12s ease;
      min-width: 160px;
      user-select:none;
      font-family: inherit;
    }
    button:hover{ transform: translateY(-1px); filter: brightness(1.03); }
    button:active{ transform: translateY(0px); filter: brightness(0.98); }
    button:disabled{
      opacity: 0.35;
      cursor:not-allowed;
      transform:none;
      filter:none;
    }
    .ghost{
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow:none;
      min-width: 160px;
    }

    /* ===== HUD ===== */
    .hud{
      width: 100%;
      display:flex;
      justify-content:center;
      user-select:none;
      z-index: 2;
      padding-top: 6px;
    }
    .hudInner{
      display:flex;
      gap: 46px;
      align-items:center;
      justify-content:center;
      padding: 6px 14px;
      border-radius: 18px;
      background: rgba(0,0,0,0.10);
      border: 1px solid rgba(255,255,255,0.06);
    }
    .hudBlock{ text-align:center; min-width: 90px; }

    .hudLabel{
      color: var(--bg);
      text-shadow: 0 0 15px var(--glow), 0 0 15px var(--glow);
      font-weight: 1100;
      font-size: 16px;
      letter-spacing: 0.5px;
    }
    .hudValue{
      margin-top: 6px;
      font-weight: 1200;
      font-size: 22px;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 0 16px rgba(0,0,0,0.65);
      font-variant-numeric: tabular-nums;
    }

    /* ===== Target + Erasure ===== */
    .targetArea{
      width: 100%;
      max-width: 1500px;
      display:flex;
      justify-content:center;
      align-items:center;
      gap: 22px;
      user-select:none;
      margin-top: 6px;
      z-index: 3;
      min-height: 190px;
    }

    .dotPanel{
      display:flex;
      flex-direction:column;
      gap: 0;
      align-items:center;
      justify-content:flex-start;
      width: fit-content;
    }
    .erRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: var(--dotDoubleGap);
      height: var(--dotCenterY);
    }
    .dotGroup{
      display:flex;
      align-items:center;
      gap: 0;
    }

    /* 중앙-중앙 간격용 슬롯 */
    .dotSlot{
      width: var(--dotCenterX);
      height: var(--dotCenterY);
      position: relative;
      flex: 0 0 auto;
    }

    .dot{
      width: var(--dotW);
      height: var(--dotH);
      object-fit: contain;
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      display:block;
      margin:0;
      padding:0;
      line-height:0;
      transform-origin: center;
    }
    .dot.lit{
      filter:
        drop-shadow(0 0 10px rgba(248,207,87,0.55))
        drop-shadow(0 0 18px rgba(248,207,87,0.22));
    }
    .dot.pulse{ animation: dotPulse 320ms ease-out; }
    @keyframes dotPulse{
      0%   { transform: translate(-50%, -50%) scale(0.92); opacity: 0.85; }
      45%  { transform: translate(-50%, -50%) scale(1.14); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1.00); }
    }

    .targetStack{
      text-align:center;
      min-width: 340px;
      padding: 0 8px;
    }
    .targetLabel{
      font-size: 44px;
      font-weight: 1100;
      letter-spacing: 1px;
      margin: 0 0 8px;
      color: var(--bg);
      text-shadow: 0 0 15px var(--glow), 0 0 15px var(--glow);
    }
    .targetValue{
      font-size: 110px;
      font-weight: 1200;
      margin: 0;
      line-height: 1.0;
      font-variant-numeric: tabular-nums;
      color: var(--gold);
      text-shadow: 0 10px 18px rgba(0,0,0,0.55);
      opacity: 0;
      transition: opacity 300ms ease;
    }
    .targetValue.show{ opacity: 1; }

    /* ===== Cards ===== */
    .cardZone{
      width: 100%;
      display:flex;
      justify-content:center;
      flex: 1 1 auto;
      min-height: 0;
      padding-bottom: 10px;
      z-index: 1;
    }

    .cardScroller{
      width: 100%;
      max-width: calc(var(--card-w) * 9 + var(--gap) * 8 + 48px);
      padding: 10px 12px 12px;
      border-radius: 18px;
      height: calc(var(--card-h) * 3 + var(--gap) * 2 + 22px);
      max-height: calc(100vh - 280px - var(--bottom-safe));
      overflow-y: auto;
      overflow-x: hidden;
      display:flex;
      justify-content:center;
      scrollbar-gutter: stable;
      position: relative;
      z-index: 1;
    }

    .cardsWrap{
      width: calc(var(--card-w) * 9 + var(--gap) * 8);
      display:flex;
      flex-wrap: wrap;
      justify-content: center;
      align-content: flex-start;
      gap: var(--gap);
      margin: 0 auto;
      position: relative;
    }

    .flipCard{
      width: var(--card-w);
      height: var(--card-h);
      perspective: 1000px;
      user-select:none;
      position: relative;
      flex: 0 0 auto;
      transition: transform 160ms ease, filter 160ms ease;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
      will-change: transform, filter, opacity;
    }

    .flipCard.spawn{
      opacity: 0;
      transform: translateY(-18px);
    }
    .flipCard.spawn.spawnIn{
      opacity: 1;
      transform: translateY(0px);
      transition: opacity 220ms ease, transform 220ms ease;
    }

    .flipInner{
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      -webkit-transform-style: preserve-3d;
      transition: transform 520ms cubic-bezier(.2,.8,.2,1);
      will-change: transform;
      transform: translateZ(0);
    }

    .flipCard.flipped .flipInner{
      transform: translateZ(0) rotateY(180deg);
    }

    .face{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      backface-visibility:hidden;
      -webkit-backface-visibility:hidden;
      overflow:hidden;
      transition: opacity 220ms ease;
    }

    .back{ opacity:1; z-index:2; transform: rotateY(0deg); }
    .front{ opacity:0; z-index:1; transform: rotateY(180deg); position: relative; }

    .flipCard.flipped .back{ opacity:0; z-index:1; }
    .flipCard.flipped .front{ opacity:1; z-index:2; }

    .faceImg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      pointer-events:none;
      -webkit-user-drag:none;
      user-select:none;
      z-index:1;
    }

    .num{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      font-weight: 1200;
      font-size: 54px;
      color: var(--gold);
      text-shadow:
        0 0 18px rgba(248,207,87,0.20),
        0 2px 0 rgba(0,0,0,0.55);
      font-variant-numeric: tabular-nums;
      pointer-events:none;
      z-index:2;
    }

    .flipCard.selectable{ cursor:pointer; }

    .flipCard.selected{
      transform: translateY(-8px) scale(1.06);
      filter:
        drop-shadow(0 16px 26px rgba(0,0,0,0.70))
        drop-shadow(0 0 18px rgba(195,169,224,0.28));
    }
    .flipCard.selected::after{
      content:"";
      position:absolute;
      inset:-6px;
      border-radius: 12px;
      border: 2px solid rgba(195,169,224,0.62);
      box-shadow: 0 0 18px rgba(195,169,224,0.22);
      pointer-events:none;
    }

    /* ===== 제출 시 “반짝 + 정답/오답 색상” 후 소거 ===== */
    .flipCard.removing{ pointer-events:none; }
    .flipCard.removing.ok{ animation: cardRemoveOk 320ms ease forwards; }
    .flipCard.removing.bad{ animation: cardRemoveBad 320ms ease forwards; }

    @keyframes cardRemoveOk{
      0%{ opacity:1; transform: scale(1.02);
        filter: drop-shadow(0 18px 30px rgba(0,0,0,0.68)) drop-shadow(0 0 14px rgba(248,207,87,0.45));}
      35%{ opacity:1; transform: scale(1.04);
        filter: drop-shadow(0 18px 30px rgba(0,0,0,0.68)) drop-shadow(0 0 26px rgba(248,207,87,0.85)) drop-shadow(0 0 46px rgba(248,207,87,0.28));}
      100%{ opacity:0; transform: scale(0.92); filter: drop-shadow(0 0 0 rgba(0,0,0,0)); }
    }
    @keyframes cardRemoveBad{
      0%{ opacity:1; transform: scale(1.02);
        filter: drop-shadow(0 18px 30px rgba(0,0,0,0.68)) drop-shadow(0 0 14px rgba(255,120,120,0.40));}
      35%{ opacity:1; transform: scale(1.04);
        filter: drop-shadow(0 18px 30px rgba(0,0,0,0.68)) drop-shadow(0 0 26px rgba(255,120,120,0.85)) drop-shadow(0 0 46px rgba(255,120,120,0.26));}
      100%{ opacity:0; transform: scale(0.92); filter: drop-shadow(0 0 0 rgba(0,0,0,0)); }
    }

    .flipCard.removing.ok::after,
    .flipCard.removing.bad::after{
      content:"";
      position:absolute;
      inset:-7px;
      border-radius: 14px;
      pointer-events:none;
      opacity:0;
      animation: rimFlash 320ms ease forwards;
    }
    .flipCard.removing.ok::after{
      border: 2px solid rgba(248,207,87,0.92);
      box-shadow: 0 0 18px rgba(248,207,87,0.55), 0 0 44px rgba(248,207,87,0.22);
    }
    .flipCard.removing.bad::after{
      border: 2px solid rgba(255,140,140,0.92);
      box-shadow: 0 0 18px rgba(255,120,120,0.48), 0 0 44px rgba(255,120,120,0.18);
    }
    @keyframes rimFlash{
      0%{ opacity:0; transform: scale(0.98); }
      30%{ opacity:1; transform: scale(1.00); }
      100%{ opacity:0; transform: scale(1.02); }
    }

    /* ===== DEBUG 배지 ===== */
    .judgeBadge{
      position:absolute;
      right: 10px;
      top: 10px;
      z-index: 4;
      font-weight: 1200;
      font-size: 20px;
      line-height: 1;
      padding: 6px 8px;
      border-radius: 12px;
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      text-shadow: 0 2px 0 rgba(0,0,0,0.55);
      pointer-events:none;
      opacity: 0.0;
      transform: translateZ(0);
    }
    .judgeBadge.show{ opacity: 1.0; }
    .judgeBadge.ok{
      color: rgba(248,207,87,0.98);
      box-shadow: 0 0 16px rgba(248,207,87,0.18);
    }
    .judgeBadge.bad{
      color: rgba(255,160,160,0.95);
      box-shadow: 0 0 16px rgba(255,120,120,0.14);
    }

    /* ===== Bottom ===== */
    .bottomBar{
      position: fixed;
      left: 0;
      right: 0;
      bottom: 18px;
      display:flex;
      justify-content:center;
      gap: 12px;
      align-items:center;
      user-select:none;
      z-index: 50;
      pointer-events:none;
    }
    .bottomBar > *{ pointer-events:auto; }

    /* ===== Result Overlay ===== */
    .overlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 999;
      padding: 18px;
      background: rgba(0,0,0,0.62);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .overlay.open{ display:flex; }

    .resultPanel{
      width: min(1100px, 94vw);
      text-align:left;
      padding: 18px 18px 18px;
      border-radius: 22px;
      background: rgba(26,19,34,0.86);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 18px 60px rgba(0,0,0,0.65);
      position: relative;
      overflow:hidden;
    }

    .resultTitle{
      font-size: 62px;
      font-weight: 1200;
      margin: 6px 0 16px;
      text-align:center;
      color: rgba(239,161,77,0.95);
      text-shadow: 0 0 18px rgba(239,161,77,0.22), 0 8px 18px rgba(0,0,0,0.55);
    }

    .resultBodyWrap{
      width: 100%;
      display:flex;
      justify-content:center;
    }

    .resultBody{
      display:grid;
      grid-template-columns: 250px auto;
      column-gap: 50px;
      align-items:start;
    }

    .resultSide{
      width: 280px;
      justify-self: end;
      text-align: right;
    }

    .resultSide .resultLabel:first-of-type{
      margin-top: 0;
    }

    .resultErasure{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
    }

    .erasureTitle{
      font-size: 26px;
      line-height: 30px;
      margin: 0 0 12px;
      color: rgba(239,161,77,0.85);
      font-weight: 1100;
    }

    .resultGrid{
      display:grid;
      grid-template-columns: repeat(9, var(--dotR));
      grid-auto-rows: var(--dotR);
      gap: var(--dotR-gap);
      align-content:start;
      padding: 10px 10px 12px;
      border-radius: 16px;
      background: rgba(0,0,0,0.12);
      border: 1px solid rgba(255,255,255,0.08);
      width: fit-content;
    }

    .resultDot{
      width: var(--dotR);
      height: var(--dotR);
      object-fit: contain;
      filter: drop-shadow(0 0 8px rgba(248,207,87,0.18));
    }
    .resultDot.lit{
      filter:
        drop-shadow(0 0 10px rgba(248,207,87,0.55))
        drop-shadow(0 0 18px rgba(248,207,87,0.22));
    }

    .resultLabel{
      font-size: 26px;
      font-weight: 1100;
      margin: 14px 0 6px;
      color: rgba(239,161,77,0.85);
    }
    .resultValue{
      font-size: 42px;
      font-weight: 1200;
      margin: 0 0 8px;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 0 14px rgba(0,0,0,0.60);
      font-variant-numeric: tabular-nums;
    }

    .scoreLabel{ margin-top: 18px; }

    .resultBtns{
      margin-top: 18px;
      display:flex;
      flex-direction:column;
      gap: 14px;
      align-items:center;
    }
    .resultBtns button{
      width: min(320px, 90%);
    }
  </style>
</head>

<body>
  <!-- Start cover -->
  <div class="startCover" id="startCover" aria-hidden="false">
    <div class="startPanel">
      <div class="startMsg">준비됐나요?!</div>
      <button id="btnGameStart" disabled>리소스 로딩 (0%)</button>
    </div>
  </div>

  <div class="wrap">
    <!-- HUD -->
    <div class="hud">
      <div class="hudInner">
        <div class="hudBlock">
          <div class="hudLabel">턴</div>
          <div class="hudValue"><span id="turnNow">0</span> / <span id="turnMax">21</span></div>
        </div>
        <div class="hudBlock">
          <div class="hudLabel">경과 시간</div>
          <div class="hudValue"><span id="elapsedNow">-</span></div>
        </div>
        <div class="hudBlock">
          <div class="hudLabel">점수</div>
          <div class="hudValue"><span id="scoreNow">0</span>점</div>
        </div>
      </div>
    </div>

    <!-- Target + Erasure -->
    <div class="targetArea">
      <div class="dotPanel left" id="dotsLeft"></div>

      <div class="targetStack">
        <div class="targetLabel">타겟</div>
        <div class="targetValue" id="targetNow">-</div>
      </div>

      <div class="dotPanel right" id="dotsRight"></div>
    </div>

    <!-- Cards -->
    <div class="cardZone">
      <div class="cardScroller" id="cardScroller">
        <div class="cardsWrap" id="cardsWrap"></div>
      </div>
    </div>
  </div>

  <!-- Bottom -->
  <div class="bottomBar">
    <button id="btnSubmit" disabled>제출</button>
    <button id="btnNextTurn">턴 넘기기</button>
    <button id="btnRestart" class="ghost">재시작</button>
    <button id="btnLobby" class="ghost">로비</button>
  </div>

  <!-- Result Overlay -->
  <div class="overlay" id="resultOverlay" aria-hidden="true">
    <div class="resultPanel" role="dialog" aria-modal="true">
      <div class="resultTitle">수행 결과</div>

      <div class="resultBodyWrap">
        <div class="resultBody">
          <div class="resultSide">
            <div class="resultLabel">진행 시간</div>
            <div class="resultValue" id="resultTime">-</div>

            <div class="resultLabel scoreLabel">점수</div>
            <div class="resultValue" id="finalScore">0</div>
          </div>

          <div class="resultErasure">
            <div class="erasureTitle">소거 결과</div>
            <div class="resultGrid" id="resultGrid"></div>
          </div>
        </div>
      </div>

      <div class="resultBtns">
        <button id="btnAgain">재시작</button>
        <button id="btnToLobby" class="ghost">로비</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Debug =====
  const DEBUG_SHOW_JUDGE = false;

  // ===== 리소스 =====
  const CARD_FRONT_URL = "https://raw.githubusercontent.com/Yuhisa-Kr/WebCardGame/main/Card_Front.png";
  const CARD_BACK_URL  = "https://raw.githubusercontent.com/Yuhisa-Kr/WebCardGame/main/Card_Back.png";

  const DOT_OFF_URL = "https://raw.githubusercontent.com/Yuhisa-Kr/WebCardGame/refs/heads/main/Card_ErasureState_Off.png";
  const DOT_ON_URL  = "https://raw.githubusercontent.com/Yuhisa-Kr/WebCardGame/refs/heads/main/Card_ErasureState_On.png";
  const DOT_BAD_URL = "https://raw.githubusercontent.com/Yuhisa-Kr/WebCardGame/refs/heads/main/Card_ErasureState_On_Incorrect.png";

  // ===== 게임 파라미터 =====
  const TOTAL_TURNS = 21;
  const FIX_TURNS = 5;
  const JACKPOT_P = 0.05;

  const DRAW_COUNT = 4;
  const DRAW_INTERVAL_MS = 100;
  const REVEAL_DELAY_MS = 2000;
  const FLIP_DURATION_MS = 520;

  // ===== ✅ 점수 규칙 (통짜 적용) =====
  const BASE_SCORE = 100;          // 기본 정답 점수(카드 1장)
  const WRONG_PENALTY = 100;       // 오답 감점(카드 1장)
  const BASE_TIME = 20.0;          // ✅ 기준 시간(초) - 20초로 확정
  const ELAPSED_TICK_MS = 100;

  // ✅ 시간 가중치 강화(가장 높은 기준): log10 * TIME_MULT
  const TIME_MULT = 5.0;           // 높일수록 빠른 유저가 더 이득 / 느리면 감점도 커짐

  // ✅ 연속 정답 보너스(가장 높은 기준): 카드 장 단위로 누적
  // - 각 정답 카드에 대해 "다음 streak"을 기준으로 보너스 산정
  // - streak은 "제출에 오답이 섞이면" 즉시 0으로 초기화
  // - 턴 넘어가도 유지
  const STREAK_STEP = 12;          // streak 1 증가당 보너스 증가량(선형)
  const STREAK_SOFT = 6;           // 완만화(너무 급격한 폭발 방지). 낮을수록 더 세짐.
  // 보너스 = STREAK_STEP * floor((streak-1) / STREAK_SOFT + 1) * (streak-1)
  // -> streak이 커질수록 점진적으로 올라가되, 너무 급폭발은 덜하게.

  // ✅ 라인 보너스(혼합형, "높은 점수가 나올 수 있는 기준")
  const LINE_CONST = 180;          // 라인 1개 완성 시 상수 보너스
  const LINE_RATE  = 0.06;         // 라인 1개 완성 시 (현재점수 * 비율) 보너스

  // ✅ 라인 구간 보너스(상수)
  const TIER_2_LINES = 450;        // 누적 완성 라인 2개 달성
  const TIER_4_LINES = 900;        // 누적 완성 라인 4개 달성
  const TIER_7_LINES = 1800;       // 누적 완성 라인 7개 달성
  const BONUS_FULL_CLEAR = 4000;   // 81칸 전체 점등 시

  // 카드 소거 애니메이션 시간
  const REMOVE_ANIM_MS = 320;

  // ===== 상태 =====
  let deck = [];        // { serial, value }
  let hand = [];        // { id, serial, value, el, badgeEl }
  let selectedIds = new Set();
  let target = null;

  let turn = 0;
  let score = 0;
  let phase = "idle";

  // ✅ 연속 정답 streak(카드 장 단위)
  let streak = 0;

  let elapsed = 0.0;
  let elapsedTimer = null;

  let revealTimer = null;
  let drawTimer = null;
  let flipTimer = null;
  let fadeTimer = null;

  let newlyDrawnIds = [];
  let runStartMs = null;
  let runEndMs = null;

  // 소거 상태 (serial 0~80) 0:off, 1:correct, 2:incorrect
  const erasureState = new Array(81).fill(0);
  const dotEls = new Array(81);
  const resultDotEls = new Array(81);

  // ✅ 라인 완성/보너스 상태
  // 라인 정의: 가로 9 + 세로 9 = 총 18라인
  const awardedLines = new Set(); // "R0".."R8","C0".."C8"
  let totalCompletedLines = 0;
  let tier2Done = false;
  let tier4Done = false;
  let tier7Done = false;
  let fullDone  = false;

  // ===== DOM =====
  const elTurnNow = document.getElementById("turnNow");
  const elTurnMax = document.getElementById("turnMax");
  const elElapsedNow = document.getElementById("elapsedNow");
  const elScoreNow = document.getElementById("scoreNow");
  const elTargetNow = document.getElementById("targetNow");

  const elCardsWrap = document.getElementById("cardsWrap");
  const cardScroller = document.getElementById("cardScroller");

  const dotsLeft = document.getElementById("dotsLeft");
  const dotsRight = document.getElementById("dotsRight");
  const resultGrid = document.getElementById("resultGrid");

  const btnSubmit = document.getElementById("btnSubmit");
  const btnNextTurn = document.getElementById("btnNextTurn");
  const btnRestart = document.getElementById("btnRestart");
  const btnLobby = document.getElementById("btnLobby");

  const startCover = document.getElementById("startCover");
  const btnGameStart = document.getElementById("btnGameStart");

  const overlay = document.getElementById("resultOverlay");
  const elFinalScore = document.getElementById("finalScore");
  const elResultTime = document.getElementById("resultTime");
  const btnAgain = document.getElementById("btnAgain");
  const btnToLobby = document.getElementById("btnToLobby");

  // ===== 유틸 =====
  const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;

  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function buildDeck(){
    const d = [];
    let serial = 0;
    for (let i=1;i<=9;i++){
      for (let j=1;j<=9;j++){
        d.push({ serial, value: i*j });
        serial++;
      }
    }
    return shuffle(d);
  }

  function pickTargetFromRemaining() {
    const pool = [];
    for (const c of hand) pool.push(c.value);
    for (const c of deck) pool.push(c.value);
    if (pool.length === 0) return randInt(1,9) * randInt(1,9);
    return pool[Math.floor(Math.random() * pool.length)];
  }

  // 같은 값 OR 배수 OR 약수
  function isGoodCard(cardValue, t){
    return (cardValue === t) || (cardValue % t === 0) || (t % cardValue === 0);
  }

  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

  // ===== ✅ 점수: 시간 가중치(강화) + 연속 정답 보너스 =====
  function timeBonus(elapsedSec){
    const e = clamp(elapsedSec, 0.1, 9999);
    // ratio > 1 이면 빠른 플레이, < 1 이면 느림
    const ratio = BASE_TIME / e;
    // log10(ratio) : 빠르면 +, 느리면 -
    return Math.floor(BASE_SCORE * TIME_MULT * Math.log10(ratio));
  }

  function streakBonus(nextStreak){
    // nextStreak: 이번 카드까지 반영된 streak (1,2,3,...)
    const s = Math.max(0, nextStreak - 1);
    if (s <= 0) return 0;

    // 완만화 계단: s가 커질수록 조금씩 더 커지되 폭발은 덜하게
    const stepBucket = Math.floor(s / STREAK_SOFT) + 1; // 1,2,3...
    return STREAK_STEP * stepBucket * s;
  }

  function pointsForCorrect(elapsedSec, nextStreak){
    // 기본 + 시간 보너스 + 연속 보너스
    const p = BASE_SCORE + timeBonus(elapsedSec) + streakBonus(nextStreak);

    // ✅ 예외 처리: 정답인데 0 이하이면 무조건 1점
    return (p <= 0) ? 1 : p;
  }

  function fmtRunTime(seconds){
    const s = Math.floor(seconds);
    const h = Math.floor(s / 3600);
    const m = Math.floor((s % 3600) / 60);
    const r = s % 60;
    if (h >= 1) return `${h}시간 ${m}분 ${r}초`;
    if (m >= 1) return `${m}분 ${r}초`;
    return `${r}초`;
  }

  function clearTimers(){
    if (revealTimer){ clearTimeout(revealTimer); revealTimer = null; }
    if (drawTimer){ clearInterval(drawTimer); drawTimer = null; }
    if (flipTimer){ clearTimeout(flipTimer); flipTimer = null; }
    if (fadeTimer){ clearTimeout(fadeTimer); fadeTimer = null; }
  }

  function stopElapsedTimer(){
    if (elapsedTimer){
      clearInterval(elapsedTimer);
      elapsedTimer = null;
    }
  }

  function startElapsedTimer(){
    stopElapsedTimer();
    elapsed = 0.0;
    renderHud();
    elapsedTimer = setInterval(() => {
      elapsed = +(elapsed + 0.1).toFixed(10);
      renderHud();
    }, ELAPSED_TICK_MS);
  }

  function scrollToBottom(){
    cardScroller.scrollTop = cardScroller.scrollHeight;
  }

  function setOverlayOpen(open){
    overlay.classList.toggle("open", open);
    overlay.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function renderHud(){
    elTurnNow.textContent = String(turn);
    elTurnMax.textContent = String(TOTAL_TURNS);
    elScoreNow.textContent = String(score);
    elElapsedNow.textContent = (phase === "play") ? `${Math.max(0, elapsed).toFixed(1)}초` : "-";
  }

  function updateSubmitEnabled(){
    btnSubmit.disabled = !(phase === "play" && selectedIds.size > 0);
  }

  function showTargetValue(){ elTargetNow.classList.add("show"); }
  function hideTargetValue(){ elTargetNow.classList.remove("show"); }

  function clearSelection(){
    selectedIds.clear();
    for (const c of hand) c.el.classList.remove("selected");
    updateSubmitEnabled();
  }

  // ===== DEBUG 배지 =====
  function refreshJudgeBadges(){
    if (!DEBUG_SHOW_JUDGE) return;
    if (!target) return;

    for (const c of hand){
      if (!c.badgeEl) continue;
      const ok = isGoodCard(c.value, target);
      c.badgeEl.textContent = ok ? "✅" : "❌";
      c.badgeEl.classList.toggle("ok", ok);
      c.badgeEl.classList.toggle("bad", !ok);
      c.badgeEl.classList.add("show");
    }
  }

  // ===== 소거 점 UI =====
  function makeImg(cls, src){
    const img = document.createElement("img");
    img.className = cls;
    img.alt = "dot";
    img.src = src;
    return img;
  }

  function makeRow(isDouble){
    const row = document.createElement("div");
    row.className = "erRow";
    if (isDouble){
      const g1 = document.createElement("div");
      g1.className = "dotGroup";
      const g2 = document.createElement("div");
      g2.className = "dotGroup";
      row.appendChild(g1);
      row.appendChild(g2);
      row._g1 = g1;
      row._g2 = g2;
    } else {
      const g = document.createElement("div");
      g.className = "dotGroup";
      row.appendChild(g);
      row._g = g;
    }
    return row;
  }

  function makeSlotWithDot(imgEl){
    const slot = document.createElement("div");
    slot.className = "dotSlot";
    slot.appendChild(imgEl);
    return slot;
  }

  function initDots(){
    dotsLeft.innerHTML = "";
    dotsRight.innerHTML = "";
    resultGrid.innerHTML = "";

    // 좌측: 9+9 / 9 / 9+9
    const L1 = makeRow(true);
    const L2 = makeRow(false);
    const L3 = makeRow(true);
    dotsLeft.append(L1, L2, L3);

    // 우측: 9 / 9+9 / 9
    const R1 = makeRow(false);
    const R2 = makeRow(true);
    const R3 = makeRow(false);
    dotsRight.append(R1, R2, R3);

    for (let s=0; s<81; s++){
      const d = makeImg("dot", DOT_OFF_URL);
      dotEls[s] = d;

      const slot = makeSlotWithDot(d);

      if (s < 45){
        if (s < 18){
          (s < 9 ? L1._g1 : L1._g2).appendChild(slot);
        } else if (s < 27){
          L2._g.appendChild(slot);
        } else {
          const k = s - 27;
          (k < 9 ? L3._g1 : L3._g2).appendChild(slot);
        }
      } else {
        const r = s - 45;
        if (r < 9){
          R1._g.appendChild(slot);
        } else if (r < 27){
          const k = r - 9;
          (k < 9 ? R2._g1 : R2._g2).appendChild(slot);
        } else {
          R3._g.appendChild(slot);
        }
      }

      // 결과 UI(9x9)
      const rd = makeImg("resultDot", DOT_OFF_URL);
      resultDotEls[s] = rd;
      resultGrid.appendChild(rd);
    }
  }

  function resetDots(){
    for (let s=0; s<81; s++){
      erasureState[s] = 0;
      const d = dotEls[s];
      const rd = resultDotEls[s];
      if (d){
        d.src = DOT_OFF_URL;
        d.classList.remove("lit","pulse");
      }
      if (rd){
        rd.src = DOT_OFF_URL;
        rd.classList.remove("lit");
      }
    }

    // ✅ 라인/티어 초기화
    awardedLines.clear();
    totalCompletedLines = 0;
    tier2Done = false;
    tier4Done = false;
    tier7Done = false;
    fullDone  = false;
  }

  function setDotState(serial, isCorrect){
    if (serial < 0 || serial >= 81) return;
    if (erasureState[serial] !== 0) return;

    erasureState[serial] = isCorrect ? 1 : 2;
    const src = isCorrect ? DOT_ON_URL : DOT_BAD_URL;

    const d = dotEls[serial];
    if (d){
      d.src = src;
      d.classList.add("lit");
      d.classList.remove("pulse");
      void d.offsetWidth;
      d.classList.add("pulse");
    }

    const rd = resultDotEls[serial];
    if (rd){
      rd.src = src;
      rd.classList.add("lit");
    }
  }

  // ===== ✅ 라인 체크/보너스 =====
  function isFilled(idx){ return erasureState[idx] !== 0; }

  function countFilled(){
    let c = 0;
    for (let i=0;i<81;i++) if (isFilled(i)) c++;
    return c;
  }

  function checkLineRow(r){
    for (let c=0;c<9;c++){
      const idx = r*9 + c;
      if (!isFilled(idx)) return false;
    }
    return true;
  }

  function checkLineCol(c){
    for (let r=0;r<9;r++){
      const idx = r*9 + c;
      if (!isFilled(idx)) return false;
    }
    return true;
  }

  function applyLineBonuses(){
    // 새로 완성된 라인 찾아서 보너스 지급
    let newLines = 0;

    for (let r=0;r<9;r++){
      const key = `R${r}`;
      if (!awardedLines.has(key) && checkLineRow(r)){
        awardedLines.add(key);
        newLines++;
      }
    }
    for (let c=0;c<9;c++){
      const key = `C${c}`;
      if (!awardedLines.has(key) && checkLineCol(c)){
        awardedLines.add(key);
        newLines++;
      }
    }

    if (newLines > 0){
      // 혼합형: (상수 + 현재점수 비율) * 라인 수
      const perLine = LINE_CONST + Math.floor(score * LINE_RATE);
      score += perLine * newLines;

      totalCompletedLines += newLines;

      // 구간 보너스(상수)
      if (!tier2Done && totalCompletedLines >= 2){
        tier2Done = true;
        score += TIER_2_LINES;
      }
      if (!tier4Done && totalCompletedLines >= 4){
        tier4Done = true;
        score += TIER_4_LINES;
      }
      if (!tier7Done && totalCompletedLines >= 7){
        tier7Done = true;
        score += TIER_7_LINES;
      }
    }

    // 전체 완성(81점등)
    if (!fullDone && countFilled() >= 81){
      fullDone = true;
      score += BONUS_FULL_CLEAR;
    }
  }

  // ===== 카드 생성 =====
  let cardIdSeq = 1;

  function createCardElement(cardId, value){
    const card = document.createElement("div");
    card.className = "flipCard spawn selectable";
    card.dataset.id = String(cardId);

    const inner = document.createElement("div");
    inner.className = "flipInner";

    const back = document.createElement("div");
    back.className = "face back";
    back.appendChild(makeImg("faceImg", CARD_BACK_URL));

    const front = document.createElement("div");
    front.className = "face front";
    front.appendChild(makeImg("faceImg", CARD_FRONT_URL));

    const num = document.createElement("div");
    num.className = "num";
    num.textContent = String(value);
    front.appendChild(num);

    const badge = document.createElement("div");
    badge.className = "judgeBadge";
    badge.textContent = "?";
    front.appendChild(badge);

    inner.appendChild(back);
    inner.appendChild(front);
    card.appendChild(inner);

    card.addEventListener("click", () => {
      if (phase !== "play") return;
      if (card.classList.contains("removing")) return;

      if (selectedIds.has(cardId)) selectedIds.delete(cardId);
      else selectedIds.add(cardId);

      card.classList.toggle("selected", selectedIds.has(cardId));
      updateSubmitEnabled();
    });

    return { cardEl: card, badgeEl: badge };
  }

  function addCardToHand(cardObj){
    const id = cardIdSeq++;
    const { cardEl, badgeEl } = createCardElement(id, cardObj.value);

    cardEl.classList.remove("flipped");
    cardEl.classList.remove("selected");

    elCardsWrap.appendChild(cardEl);
    requestAnimationFrame(() => cardEl.classList.add("spawnIn"));

    const entry = { id, serial: cardObj.serial, value: cardObj.value, el: cardEl, badgeEl };
    hand.push(entry);
    newlyDrawnIds.push(id);

    requestAnimationFrame(scrollToBottom);
    return id;
  }

  function clearAllCards(){
    hand = [];
    selectedIds.clear();
    elCardsWrap.innerHTML = "";
    updateSubmitEnabled();
  }

  // ===== 턴 진행 =====
  function startGameSession(){
    clearTimers();
    stopElapsedTimer();
    setOverlayOpen(false);

    deck = buildDeck();
    clearAllCards();
    resetDots();

    turn = 0;
    score = 0;
    target = null;
    phase = "idle";

    // ✅ streak 초기화
    streak = 0;

    runStartMs = performance.now();
    runEndMs = null;

    hideTargetValue();
    elTargetNow.textContent = "-";

    renderHud();
    updateSubmitEnabled();
    nextTurn(false);
  }

  function nextTurn(withFade){
    if (turn >= TOTAL_TURNS){
      endGame();
      return;
    }

    const start = () => {
      turn += 1;

      const isLastTurn = (turn === TOTAL_TURNS);
      const isFixZone = (turn >= (TOTAL_TURNS - FIX_TURNS + 1));

      if (isLastTurn && Math.random() < JACKPOT_P) {
        target = 1;
      } else if (isFixZone) {
        target = pickTargetFromRemaining();
      } else {
        target = randInt(1,9) * randInt(1,9);
      }

      elTargetNow.textContent = String(target);

      clearSelection();
      newlyDrawnIds = [];
      phase = "reveal";

      renderHud();
      updateSubmitEnabled();

      showTargetValue();
      refreshJudgeBadges();

      revealTimer = setTimeout(() => beginDraw(), REVEAL_DELAY_MS);
    };

    stopElapsedTimer();
    renderHud();

    if (withFade){
      hideTargetValue();
      fadeTimer = setTimeout(start, 300);
    } else {
      start();
    }
  }

  function beginDraw(){
    if (phase !== "reveal") return;

    phase = "drawing";
    renderHud();
    updateSubmitEnabled();

    let drawn = 0;
    drawTimer = setInterval(() => {
      if (drawn >= DRAW_COUNT || deck.length <= 0){
        clearInterval(drawTimer);
        drawTimer = null;
        beginFlipAllNew();
        return;
      }
      addCardToHand(deck.pop());
      drawn += 1;
    }, DRAW_INTERVAL_MS);
  }

  function beginFlipAllNew(){
    phase = "flipping";
    renderHud();
    updateSubmitEnabled();

    for (const id of newlyDrawnIds){
      const c = hand.find(x => x.id === id);
      if (c) c.el.classList.add("flipped");
    }

    flipTimer = setTimeout(() => beginPlay(), FLIP_DURATION_MS + 40);
  }

  function beginPlay(){
    phase = "play";
    renderHud();
    updateSubmitEnabled();
    startElapsedTimer();
    refreshJudgeBadges();
  }

  function submitTurn(){
    if (phase !== "play") return;
    if (selectedIds.size <= 0) return;

    const elapsedAtSubmit = clamp(elapsed, 0.1, 9999);
    const ids = Array.from(selectedIds);

    // 이번 제출에 오답이 섞였는지 먼저 판정
    let hasWrong = false;
    let selectedCards = [];
    for (const id of ids){
      const c = hand.find(x => x.id === id);
      if (!c) continue;
      const ok = isGoodCard(c.value, target);
      if (!ok) hasWrong = true;
      selectedCards.push({ c, ok });
    }

    let deltaTotal = 0;

    // ✅ streak 규칙:
    // - 오답 섞이면 "이번 제출 후" streak=0
    // - 전부 정답이면 카드 장수만큼 streak 증가
    // - 점수는 "각 카드 처리 시점의 nextStreak" 기준으로 지급
    let localStreak = hasWrong ? 0 : streak;

    let correctCount = 0;
    for (const { c, ok } of selectedCards){
      if (ok){
        const nextStreak = localStreak + 1;
        const p = pointsForCorrect(elapsedAtSubmit, nextStreak); // ✅ 정답 0 이하 -> 1점 처리 포함
        deltaTotal += p;

        localStreak = nextStreak;
        correctCount++;

      } else {
        deltaTotal -= WRONG_PENALTY;
      }

      setDotState(c.serial, ok);

      // UI: 반짝 + 제거
      c.el.classList.remove("selected");
      c.el.classList.add("removing", ok ? "ok" : "bad");
    }

    // 점수 반영
    score += deltaTotal;

    // ✅ 라인/티어/풀클리어 보너스 적용
    applyLineBonuses();

    // ✅ streak 최종 반영
    if (hasWrong) streak = 0;
    else streak = streak + correctCount;

    stopElapsedTimer();
    clearTimers();
    clearSelection();
    phase = "idle";
    renderHud();
    updateSubmitEnabled();

    setTimeout(() => {
      const toRemove = new Set(ids);
      hand = hand.filter(c => {
        if (!toRemove.has(c.id)) return true;
        c.el.remove();
        return false;
      });

      requestAnimationFrame(scrollToBottom);
      nextTurn(true);
    }, REMOVE_ANIM_MS + 10);
  }

  function skipTurn(){
    if (phase !== "play") return;

    stopElapsedTimer();
    clearTimers();
    clearSelection();

    // ✅ 턴 넘기기는 streak 유지 (요구사항)
    phase = "idle";
    renderHud();
    updateSubmitEnabled();
    nextTurn(true);
  }

  function endGame(){
    clearTimers();
    stopElapsedTimer();
    clearSelection();

    phase = "ended";
    renderHud();
    updateSubmitEnabled();

    runEndMs = performance.now();
    const elapsedSec = (runEndMs - runStartMs) / 1000;

    elFinalScore.textContent = String(score);
    elResultTime.textContent = fmtRunTime(elapsedSec);

    setOverlayOpen(true);
  }

  // ===== 버튼 =====
  btnSubmit.addEventListener("click", submitTurn);
  btnNextTurn.addEventListener("click", skipTurn);

  btnRestart.addEventListener("click", () => startGameSession());
  btnLobby.addEventListener("click", () => window.location.href = "MR_Lobby.html");

  btnAgain.addEventListener("click", () => {
    setOverlayOpen(false);
    startGameSession();
  });
  btnToLobby.addEventListener("click", () => window.location.href = "MR_Lobby.html");

  btnGameStart.addEventListener("click", () => {
    startCover.classList.add("hide");
    startGameSession();
  });

  // ===== 로딩: 버튼 텍스트만 =====
  function preloadOne(url){
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    });
  }

  async function preloadWithProgress(urls, onProgress){
    let done = 0;
    const total = urls.length;
    for (const url of urls){
      const ok = await preloadOne(url);
      done++;
      const pct = Math.round((done / total) * 100);
      onProgress(pct, ok);
    }
  }

  (async () => {
    initDots();
    elTurnMax.textContent = String(TOTAL_TURNS);

    btnGameStart.disabled = true;
    btnGameStart.textContent = "리소스 로딩 (0%)";

    let allOk = true;
    const urls = [CARD_FRONT_URL, CARD_BACK_URL, DOT_OFF_URL, DOT_ON_URL, DOT_BAD_URL];

    await preloadWithProgress(urls, (pct, ok) => {
      if (!ok) allOk = false;

      if (pct >= 100){
        if (allOk){
          btnGameStart.textContent = "준비 완료";
          btnGameStart.disabled = false;
        } else {
          btnGameStart.textContent = "리소스 로딩 (100%)";
          btnGameStart.disabled = true;
        }
      } else {
        btnGameStart.textContent = `리소스 로딩 (${pct}%)`;
      }
    });
  })();

  // 제출 버튼 상태 안전 갱신
  setInterval(() => updateSubmitEnabled(), 120);
})();
</script>
</body>
</html>
